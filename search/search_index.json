{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Getting started import { mount } from \"@eusoft/webapp-core\"; const root = document.querySelector(\"body\"); mount(root, <div>Hello word</div>);","title":"Home"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#getting-started","text":"import { mount } from \"@eusoft/webapp-core\"; const root = document.querySelector(\"body\"); mount(root, <div>Hello word</div>);","title":"Getting started"},{"location":"components/","text":"Components Functional Component This example shows a simple functional component: function MyComponent(props: { text: string }) { const show = () => { alert(props.text); }; return ( <div> {props.text} <button on-click={ev => show()}>Show</button> </div> ); } Explanation : A functional component is a function that receives props as input and returns JSX. In this example, the show function simply displays the text property in an alert box. Class Component Why Use a Class Component? In functional components, the internal state is encapsulated and cannot be accessed or extended directly from outside the component. If you need to modify or trigger actions on the component\u2019s state from outside, class components are more suitable. Here\u2019s an example of a class component: import { Component, type IComponentOptions } from \"@eusoft/webapp-core\"; import { forModel } from \"@eusoft/webapp-jsx\"; interface IOptions extends IComponentOptions { text: string; } export class MyComponent extends Component<IOptions> { constructor(options: IOptions) { super(); this.init(MyComponent, { template: forModel<this>(m => ( <div> {m.text} <button on-click={ev => m.show()}>Show</button> </div> )), ...options, }); } show() { alert(this.text); } text: string; } Key points : The class must extend Component or a subclass of it. The constructor must call this.init(MyComponent, {...options}) , where MyComponent is the class name. The options argument should extend IComponentOptions . Compact Form To reduce boilerplate code, you can use the declareComponent helper function to declare a class component more concisely. The first argument is an object containing the class body (methods and properties), and the second argument is the component\u2019s template or default options. Example: import { declareComponent } from \"@eusoft/webapp-core\"; const MyComponent = declareComponent({ show: function () { alert(this.text); }, text: undefined as string, }, m => ( <div> {m.text} <button on-click={ev => m.show()}>Show</button> </div> )); MyComponent is now a standard class component that you can: Instantiate directly: const x = new MyComponent({ text: \"Hello\" }); Use as a JSX element: <MyComponent text=\"Hello\" /> Extend in other class components: class MyNewComponent extends MyComponent { /* ... */ } Referencing a Class Component Here\u2019s how you can reference a class component instance in a functional component: const TextInput = declareComponent ({ selectAll : function () { ( this . context . element as HTMLInputElement ). select (); }, }, m => < input type = \"text\" /> ); function Page () { const state : { input? : InstanceType < typeof TextInput > ; } = {}; return ( < div > < TextInput ref = { state . input } /> < button on - click = {() => state . input . selectAll ()} > Select < /button> < /div> ); } Explanation : - TextInput is a class component that includes a selectAll method. - The Page component is a functional component. It declares a reference to the TextInput instance using the ref attribute. - When the Select button is clicked, it calls selectAll() on the TextInput instance, which selects all the text in the input field. - The underlying DOM element of TextInput is accessible via this.context.element . This demonstrates how class components can expose methods that can be called from outside the component, something that functional components do not provide by default.","title":"Components"},{"location":"components/#components","text":"","title":"Components"},{"location":"components/#functional-component","text":"This example shows a simple functional component: function MyComponent(props: { text: string }) { const show = () => { alert(props.text); }; return ( <div> {props.text} <button on-click={ev => show()}>Show</button> </div> ); } Explanation : A functional component is a function that receives props as input and returns JSX. In this example, the show function simply displays the text property in an alert box.","title":"Functional Component"},{"location":"components/#class-component","text":"","title":"Class Component"},{"location":"components/#why-use-a-class-component","text":"In functional components, the internal state is encapsulated and cannot be accessed or extended directly from outside the component. If you need to modify or trigger actions on the component\u2019s state from outside, class components are more suitable. Here\u2019s an example of a class component: import { Component, type IComponentOptions } from \"@eusoft/webapp-core\"; import { forModel } from \"@eusoft/webapp-jsx\"; interface IOptions extends IComponentOptions { text: string; } export class MyComponent extends Component<IOptions> { constructor(options: IOptions) { super(); this.init(MyComponent, { template: forModel<this>(m => ( <div> {m.text} <button on-click={ev => m.show()}>Show</button> </div> )), ...options, }); } show() { alert(this.text); } text: string; } Key points : The class must extend Component or a subclass of it. The constructor must call this.init(MyComponent, {...options}) , where MyComponent is the class name. The options argument should extend IComponentOptions .","title":"Why Use a Class Component?"},{"location":"components/#compact-form","text":"To reduce boilerplate code, you can use the declareComponent helper function to declare a class component more concisely. The first argument is an object containing the class body (methods and properties), and the second argument is the component\u2019s template or default options. Example: import { declareComponent } from \"@eusoft/webapp-core\"; const MyComponent = declareComponent({ show: function () { alert(this.text); }, text: undefined as string, }, m => ( <div> {m.text} <button on-click={ev => m.show()}>Show</button> </div> )); MyComponent is now a standard class component that you can: Instantiate directly: const x = new MyComponent({ text: \"Hello\" }); Use as a JSX element: <MyComponent text=\"Hello\" /> Extend in other class components: class MyNewComponent extends MyComponent { /* ... */ }","title":"Compact Form"},{"location":"components/#referencing-a-class-component","text":"Here\u2019s how you can reference a class component instance in a functional component: const TextInput = declareComponent ({ selectAll : function () { ( this . context . element as HTMLInputElement ). select (); }, }, m => < input type = \"text\" /> ); function Page () { const state : { input? : InstanceType < typeof TextInput > ; } = {}; return ( < div > < TextInput ref = { state . input } /> < button on - click = {() => state . input . selectAll ()} > Select < /button> < /div> ); } Explanation : - TextInput is a class component that includes a selectAll method. - The Page component is a functional component. It declares a reference to the TextInput instance using the ref attribute. - When the Select button is clicked, it calls selectAll() on the TextInput instance, which selects all the text in the input field. - The underlying DOM element of TextInput is accessible via this.context.element . This demonstrates how class components can expose methods that can be called from outside the component, something that functional components do not provide by default.","title":"Referencing a Class Component"},{"location":"elements/","text":"Elements Content Builder t.content(m=> m.myContent) JSX <Content src = {m.myContent} /> Expression <tagName>{m.myContent}</tagName> If Builder t.if(m=> m.test == 2, t1 => t1.text(\"True\"), t1 => t1.text(\"False\")) JSX <If condition = {m.test == 2} > True <Else>False</Else> </If> Expression <tagName> {m.test == 2 ? <>True</> : <>False</> } </tagName> <tagName>{m.test == 2 && <>True not else</>}</tagName> Class Builder t.class(m=> m.myClassList); t.class(m=> \"my-class\", m => m.myProp == true); JSX <div> <Class condition = {m.myProp == true} name=\"my-class\" /> <Class name={m.myClassList} /> </div> <div className=\"class1 class2\"/> Style Builder t => t.styles({ \"color\": m=> m.myColor, \"font-size\": \"13px\" }) t => t.style(\"color\", m=> m.myColor) JSX <div style={{color: m.myColor}}> <Style color={m.MyColor} fontSize=\"16px\" /> </div> Foreach Builder t => t.foreach(m => m.items, t2 => t2.text(item => item.myItemProp)); JSX <Foreach src={m.items} as=\"item\"> {item.myItemProp} </Foreach> Expression {m.items.forEach(i=> <>{i.myItemProp}</>)} Warning Do not use map function of an array, since will behave as expected (transform an array to another array), not bind an array","title":"Elements"},{"location":"elements/#elements","text":"","title":"Elements"},{"location":"elements/#content","text":"Builder t.content(m=> m.myContent) JSX <Content src = {m.myContent} /> Expression <tagName>{m.myContent}</tagName>","title":"Content"},{"location":"elements/#if","text":"Builder t.if(m=> m.test == 2, t1 => t1.text(\"True\"), t1 => t1.text(\"False\")) JSX <If condition = {m.test == 2} > True <Else>False</Else> </If> Expression <tagName> {m.test == 2 ? <>True</> : <>False</> } </tagName> <tagName>{m.test == 2 && <>True not else</>}</tagName>","title":"If"},{"location":"elements/#class","text":"Builder t.class(m=> m.myClassList); t.class(m=> \"my-class\", m => m.myProp == true); JSX <div> <Class condition = {m.myProp == true} name=\"my-class\" /> <Class name={m.myClassList} /> </div> <div className=\"class1 class2\"/>","title":"Class"},{"location":"elements/#style","text":"Builder t => t.styles({ \"color\": m=> m.myColor, \"font-size\": \"13px\" }) t => t.style(\"color\", m=> m.myColor) JSX <div style={{color: m.myColor}}> <Style color={m.MyColor} fontSize=\"16px\" /> </div>","title":"Style"},{"location":"elements/#foreach","text":"Builder t => t.foreach(m => m.items, t2 => t2.text(item => item.myItemProp)); JSX <Foreach src={m.items} as=\"item\"> {item.myItemProp} </Foreach> Expression {m.items.forEach(i=> <>{i.myItemProp}</>)} Warning Do not use map function of an array, since will behave as expected (transform an array to another array), not bind an array","title":"Foreach"}]}