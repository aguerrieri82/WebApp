{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Getting started import { mount } from \"@eusoft/webapp-core\"; const root = document.querySelector(\"body\"); mount(root, <div>Hello word</div>);","title":"Home"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#getting-started","text":"import { mount } from \"@eusoft/webapp-core\"; const root = document.querySelector(\"body\"); mount(root, <div>Hello word</div>);","title":"Getting started"},{"location":"components/","text":"Components Functional Component This example shows a simple functional component: function MyComponent ( props : { text : string }) { const show = () => { alert ( props . text ); }; return ( < div > { props . text } < button on - click = { ev => show ()} > Show < /button> < /div> ); } < MyComponent text = \"\" /> Explanation : A functional component is a function that receives props as input and returns JSX. In this example, the show function simply displays the text property in an alert box. Note The function is called only once during its lifecycle and is not re-executed when properties change. State Internal state can be tracked using a special const state = {} object You can configure the compiler to automatically track changes to specific variables: { au t oTrack : [ \"myVarName\" , /myRegExp/ ] } Alternatively, decorate the variable with Bind.track , for example: const myState = Bind.track({...}) . Warning The variable must be declared with const and initialized as an object. Example function App ( p : { theme : string }) { const state = { text : \"\" , }; const show = () => { alert ( state . text ); state . text = \"new\" ; }; return ( < main clasName = { p . theme } > < h1 > Function component < /h1> < input type = \"text\" value = { state . text } /> < button on - click = { show } > Show < /button> < /main> ) } Class Component Why Use a Class Component? In functional components, the internal state is encapsulated and cannot be accessed or extended directly from outside the component. If you need to modify or trigger actions on the component\u2019s state from outside, class components are more suitable. Here\u2019s an example of a class component: import { Component , type IComponentOptions } from \"@eusoft/webapp-core\" ; import { forModel } from \"@eusoft/webapp-jsx\" ; interface IOptions extends IComponentOptions { text : string ; } export class MyComponent extends Component < IOptions > { constructor ( options : IOptions ) { super (); this . init ( MyComponent , { template : forModel < this > ( m => ( < div > { m . text } < button on - click = { ev => m . show ()} > Show < /button> < /div> )), ... options , }); } show () { alert ( this . text ); } text : string ; } Key points : The class must extend Component or a subclass of it. The constructor must call this.init(MyComponent, {...options}) , where MyComponent is the class name. The options argument should extend IComponentOptions . Note All properties in options that have a corrispictive in the components class, will be automaticated assigned. Only properties in options intreface will be exposed as JSX attributes Compact Form To reduce boilerplate code, you can use the declareComponent helper function to declare a class component more concisely. The first argument is an object containing the class body (methods and properties), and the second argument is the component\u2019s template or default options. Example: import { declareComponent } from \"@eusoft/webapp-core\" ; const MyComponent = declareComponent ({ show : function () { alert ( this . text ); }, text : undefined as string }, m => ( < div > { m . text } < button on - click = { ev => m . show ()} > Show < /button> < /div> )); MyComponent is now a standard class component that you can: Instantiate directly: const x = new MyComponent({ text: \"Hello\" }); Use as a JSX element: <MyComponent text=\"Hello\" /> Extend in other class components: class MyNewComponent extends MyComponent { /* ... */ } Warning All properties must be initialized with a default value, that can be null / undefined Referencing a Class Component Here\u2019s how you can reference a class component instance in a functional component: const TextInput = declareComponent ({ selectAll : function () { ( this . context . element as HTMLInputElement ). select (); } }, m => < input type = \"text\" /> ); function Page () { const state : { input? : InstanceType < typeof TextInput > ; } = {}; return ( < div > < TextInput ref = { state . input } /> < button on - click = {() => state . input . selectAll ()} > Select < /button> < /div> ); } Explanation : - TextInput is a class component that includes a selectAll method. - The Page component is a functional component. It declares a reference to the TextInput instance using the ref attribute. - The underlying DOM element of TextInput is accessible via this.context.element . This demonstrates how class components can expose methods that can be called from outside the component, something that functional components do not provide by default. Options / Attributes / Props A class component\u2019s available JSX attributes are defined by the type of its options parameter. Specifically, this type is declared as the first generic argument of Component<TOptions> , and it determines which attributes can be set when using the component in JSX. In functional components, instead, the available JSX attributes correspond to the properties of the first argument passed to the function. The special content option maps to the child nodes declared inside your component in JSX. function MyComponent ( opt : { content : ViewNode }) { return < div > { opt . content } < /div>; } < MyComponent > < span > Hello < /span> < /MyComponent> If no content type is specified, the component cannot have children. If multiple children are supported, the content type must be an array. To support both JSX and code-based initialization and to constrain the content to a particular component type, declare it as: MyChildComponent | JsxTypedComponent < IMyChildComponentOptions > If any content is permissible, use the type ViewNode (which covers both single and multiple children). To make an option bindable, meaning it dynamically reacts to changes, it must be declared as Bindable . interface IMyOptions { text : Bindable < string > ; } A bindable option can accept different types of values: A direct value An observable property (something implementing IObservableProperty or extracted from an object using propOf ) A property/bind expression from an external model using Bind.external const myModel = { counter : 0 }; interface IMyComponentOptions { value1 : Bindable < number > ; value2 : Bindable < number > ; value3 : Bindable < string > ; value4 : Bindable < number > ; } const x = new MyComponent ({ value1 : 5 , value2 : Bind.external ( myModel , \"counter\" ), value3 : Bind.external ( myModel , a => a . counter . toString () + \" ticks\" ), value4 : propOf ( myModel , \"counter\" ) }); Note Unfortunately, there is no way to enforce strict type checks on these attributes in JSX, so any attribute is treated as \"bindable\" by default. In functional components, the actual values passed to props can be bind expressions (e.g., m => m.xxx ). These values are not meant to be read or manipulated outside the JSX. To enforce type check and avoid confusion, declare such options always as Bindable","title":"Components"},{"location":"components/#components","text":"","title":"Components"},{"location":"components/#functional-component","text":"This example shows a simple functional component: function MyComponent ( props : { text : string }) { const show = () => { alert ( props . text ); }; return ( < div > { props . text } < button on - click = { ev => show ()} > Show < /button> < /div> ); } < MyComponent text = \"\" /> Explanation : A functional component is a function that receives props as input and returns JSX. In this example, the show function simply displays the text property in an alert box. Note The function is called only once during its lifecycle and is not re-executed when properties change.","title":"Functional Component"},{"location":"components/#state","text":"Internal state can be tracked using a special const state = {} object You can configure the compiler to automatically track changes to specific variables: { au t oTrack : [ \"myVarName\" , /myRegExp/ ] } Alternatively, decorate the variable with Bind.track , for example: const myState = Bind.track({...}) . Warning The variable must be declared with const and initialized as an object. Example function App ( p : { theme : string }) { const state = { text : \"\" , }; const show = () => { alert ( state . text ); state . text = \"new\" ; }; return ( < main clasName = { p . theme } > < h1 > Function component < /h1> < input type = \"text\" value = { state . text } /> < button on - click = { show } > Show < /button> < /main> ) }","title":"State"},{"location":"components/#class-component","text":"","title":"Class Component"},{"location":"components/#why-use-a-class-component","text":"In functional components, the internal state is encapsulated and cannot be accessed or extended directly from outside the component. If you need to modify or trigger actions on the component\u2019s state from outside, class components are more suitable. Here\u2019s an example of a class component: import { Component , type IComponentOptions } from \"@eusoft/webapp-core\" ; import { forModel } from \"@eusoft/webapp-jsx\" ; interface IOptions extends IComponentOptions { text : string ; } export class MyComponent extends Component < IOptions > { constructor ( options : IOptions ) { super (); this . init ( MyComponent , { template : forModel < this > ( m => ( < div > { m . text } < button on - click = { ev => m . show ()} > Show < /button> < /div> )), ... options , }); } show () { alert ( this . text ); } text : string ; } Key points : The class must extend Component or a subclass of it. The constructor must call this.init(MyComponent, {...options}) , where MyComponent is the class name. The options argument should extend IComponentOptions . Note All properties in options that have a corrispictive in the components class, will be automaticated assigned. Only properties in options intreface will be exposed as JSX attributes","title":"Why Use a Class Component?"},{"location":"components/#compact-form","text":"To reduce boilerplate code, you can use the declareComponent helper function to declare a class component more concisely. The first argument is an object containing the class body (methods and properties), and the second argument is the component\u2019s template or default options. Example: import { declareComponent } from \"@eusoft/webapp-core\" ; const MyComponent = declareComponent ({ show : function () { alert ( this . text ); }, text : undefined as string }, m => ( < div > { m . text } < button on - click = { ev => m . show ()} > Show < /button> < /div> )); MyComponent is now a standard class component that you can: Instantiate directly: const x = new MyComponent({ text: \"Hello\" }); Use as a JSX element: <MyComponent text=\"Hello\" /> Extend in other class components: class MyNewComponent extends MyComponent { /* ... */ } Warning All properties must be initialized with a default value, that can be null / undefined","title":"Compact Form"},{"location":"components/#referencing-a-class-component","text":"Here\u2019s how you can reference a class component instance in a functional component: const TextInput = declareComponent ({ selectAll : function () { ( this . context . element as HTMLInputElement ). select (); } }, m => < input type = \"text\" /> ); function Page () { const state : { input? : InstanceType < typeof TextInput > ; } = {}; return ( < div > < TextInput ref = { state . input } /> < button on - click = {() => state . input . selectAll ()} > Select < /button> < /div> ); } Explanation : - TextInput is a class component that includes a selectAll method. - The Page component is a functional component. It declares a reference to the TextInput instance using the ref attribute. - The underlying DOM element of TextInput is accessible via this.context.element . This demonstrates how class components can expose methods that can be called from outside the component, something that functional components do not provide by default.","title":"Referencing a Class Component"},{"location":"components/#options-attributes-props","text":"A class component\u2019s available JSX attributes are defined by the type of its options parameter. Specifically, this type is declared as the first generic argument of Component<TOptions> , and it determines which attributes can be set when using the component in JSX. In functional components, instead, the available JSX attributes correspond to the properties of the first argument passed to the function. The special content option maps to the child nodes declared inside your component in JSX. function MyComponent ( opt : { content : ViewNode }) { return < div > { opt . content } < /div>; } < MyComponent > < span > Hello < /span> < /MyComponent> If no content type is specified, the component cannot have children. If multiple children are supported, the content type must be an array. To support both JSX and code-based initialization and to constrain the content to a particular component type, declare it as: MyChildComponent | JsxTypedComponent < IMyChildComponentOptions > If any content is permissible, use the type ViewNode (which covers both single and multiple children). To make an option bindable, meaning it dynamically reacts to changes, it must be declared as Bindable . interface IMyOptions { text : Bindable < string > ; } A bindable option can accept different types of values: A direct value An observable property (something implementing IObservableProperty or extracted from an object using propOf ) A property/bind expression from an external model using Bind.external const myModel = { counter : 0 }; interface IMyComponentOptions { value1 : Bindable < number > ; value2 : Bindable < number > ; value3 : Bindable < string > ; value4 : Bindable < number > ; } const x = new MyComponent ({ value1 : 5 , value2 : Bind.external ( myModel , \"counter\" ), value3 : Bind.external ( myModel , a => a . counter . toString () + \" ticks\" ), value4 : propOf ( myModel , \"counter\" ) }); Note Unfortunately, there is no way to enforce strict type checks on these attributes in JSX, so any attribute is treated as \"bindable\" by default. In functional components, the actual values passed to props can be bind expressions (e.g., m => m.xxx ). These values are not meant to be read or manipulated outside the JSX. To enforce type check and avoid confusion, declare such options always as Bindable","title":"Options / Attributes / Props"},{"location":"elements/","text":"Elements This chapter describes the different building blocks of the framework\u2019s rendering system, including how to define templates, bind data, and handle dynamic DOM updates. It covers the syntax and conventions for building reactive interfaces with both the fluent API (Builder) and JSX syntax. The elements and attributes described here allow you to construct flexible, data-driven UIs with live updates and minimal manual DOM management. Some elements are automatically detected using an expression inside the JSX as a shortcut. Template Define a new template. A template is a function that builds or updates a DOM tree for a given model. The template is \"live\": it monitors the model for changes and updates the DOM accordingly. At least one template must be mounted in your document using the mount(elementOrSelector, template) function. Builder import { template } from \"@eusoft/webapp-core\" ; template ( t => t ); JSX import { forModel } from \"@eusoft/webapp-jsx\" ; forModel < TModel > ( m => <> < />); forModel ( myModel , m => <> < />); < Template name = \"\" > < /Template> HTML Elements Standard HTML elements can be created using the fluent API in the template builder. In JSX, events are mapped using special on-* attributes, where * is the event name (e.g., on-click ). In addition to standard HTML attributes: focus : two-way boolean expression to get/set the focus status. visible : adds or removes the \"visible\" or \"hidden\" class to an element based on the boolean expression. html : sets the inner HTML of an element. text : sets the inner text of an element. For input , textarea , and select elements: value-mode : determines how the value update must be notified: change : when the value changes (default). focus : when the element loses focus. input : when the value changes due to user input. keyup : after every keyup event. pool : periodically checks for value changes every value-pool milliseconds. value-pool : interval in milliseconds (default: 500). Builder template ( t => t . beginChild ( \"div\" ). class ( \"myClass\" ) . beginChild ( \"span\" ). set ( \"title\" , \"a span\" ) . text ( \"Text\" ) . endChild () . beginChild ( \"button\" ). on ( \"click\" , ev => console . log ( \"Clicked!\" )) . text ( \"Click me\" ) . endChild () . endChild ()); JSX < div className = \"myClass\" > < span title = \"a span\" > Text < /span> < button on - click = { ev => console . log ( \"Clicked!\" )} > Click me < /button> < /div> Component Builder t . component ( MyComponent , { attr1 : \"value\" , attr2 : m => m . modelProp }) JSX < MyComponent attr1 = \"value\" attr2 = { m . modelProp } /> Content Renders the specified content. Valid content types are: Primitive types: String, Number, Boolean Components Templates Template providers {model: ..., template: ...} An object with an associated template using setTemplate Arrays of valid content You can override the default template associated with the model by specifying the template attribute. Warning A content array is not observed for internal changes, but only when the whole array object changes. To observe an array, use the Foreach element or expression. Builder t . content ( m => m . myContent ) JSX < Content src = { m . myContent } /> < Content src = { m . myContent } template = { myTemplate } /> Expression < tagName > { m . myContent } < /tagName> If Conditionally render a subtree if the condition is true. You can optionally specify a false subtree. This allows toggling parts of the UI based on the model\u2019s state. Builder t . if ( m => m . test == 2 , t1 => t1 . text ( \"True\" ), t1 => t1 . text ( \"False\" )); JSX < If condition = { m . test == 2 } > True < Else > False < /Else> < /If> Expression < tagName > { m . test == 2 ? <> True < /> : <> False < /> } < /tagName> < tagName > { m . test == 2 && <> True ( no else ) < />}</tagName> Class Adds a class list to an HTML element or conditionally adds/removes it when a given expression is true. Builder t . class ( m => m . myClassList ); t . class ( m => \"my-class\" , m => m . myProp === true ); JSX < div > < Class condition = { m . myProp === true } name = \"my-class\" /> < Class name = { m . myClassList } /> < /div> < div className = \"class1 class2\" /> Style Associates a static style object to an HTML element or dynamically binds a particular state property. Builder t => t . styles ({ \"color\" : m => m . myColor , \"font-size\" : \"13px\" }) t => t . style ( \"color\" , m => m . myColor ) JSX < div > < Style color = { m . myColor } fontSize = \"16px\" /> < /div> < div style = {{ color : m.myColor }} /> < div style - color = { m . myColor } /> Warning Static style properties provided as {styleProp: value, ...} won\u2019t be bound and will maintain their initial value. Foreach Specifies a template to be applied to each element of an array. The array is observed for subsequent changes and updates atomically propagate. Observed methods include: push , pop , sort , splice , shift , unshift , fill . To change an element\u2019s value, use the new non-standard set function or proxy the array using createObservableArray . Builder t => t . foreach ( m => m . items , t2 => t2 . beginChild ( \"span\" ) . text ( item => item . myItemProp ) . endChild ()); JSX < Foreach src = { m . items } > < span > { item . myItemProp } < /span> < /Foreach> Expression { m . items . forEach ( i => < span > { i . myItemProp } < /span>)} Warning Do not use the map function on an array here, as it behaves as expected for transformations (producing a new array) but does not bind the array. Warning Original array methods such as push will be overridden. Consider this for subsequent bulk operations on such arrays. Text Creates a text node. Builder t => t . text ( m => m . myText ) JSX < Text src = { m . myText } /> Node Appends a DOM node as a child of the current element. Builder t => t . appendChild ( m => m . myDOMnode ) JSX < Node src = { m . myDOMnode } /> Html Creates elements from an HTML string. Builder t => t . html ( m => m . myHtmlString ) JSX < Html src = { m . myHtmlString } />","title":"Elements"},{"location":"elements/#elements","text":"This chapter describes the different building blocks of the framework\u2019s rendering system, including how to define templates, bind data, and handle dynamic DOM updates. It covers the syntax and conventions for building reactive interfaces with both the fluent API (Builder) and JSX syntax. The elements and attributes described here allow you to construct flexible, data-driven UIs with live updates and minimal manual DOM management. Some elements are automatically detected using an expression inside the JSX as a shortcut.","title":"Elements"},{"location":"elements/#template","text":"Define a new template. A template is a function that builds or updates a DOM tree for a given model. The template is \"live\": it monitors the model for changes and updates the DOM accordingly. At least one template must be mounted in your document using the mount(elementOrSelector, template) function. Builder import { template } from \"@eusoft/webapp-core\" ; template ( t => t ); JSX import { forModel } from \"@eusoft/webapp-jsx\" ; forModel < TModel > ( m => <> < />); forModel ( myModel , m => <> < />); < Template name = \"\" > < /Template>","title":"Template"},{"location":"elements/#html-elements","text":"Standard HTML elements can be created using the fluent API in the template builder. In JSX, events are mapped using special on-* attributes, where * is the event name (e.g., on-click ). In addition to standard HTML attributes: focus : two-way boolean expression to get/set the focus status. visible : adds or removes the \"visible\" or \"hidden\" class to an element based on the boolean expression. html : sets the inner HTML of an element. text : sets the inner text of an element. For input , textarea , and select elements: value-mode : determines how the value update must be notified: change : when the value changes (default). focus : when the element loses focus. input : when the value changes due to user input. keyup : after every keyup event. pool : periodically checks for value changes every value-pool milliseconds. value-pool : interval in milliseconds (default: 500). Builder template ( t => t . beginChild ( \"div\" ). class ( \"myClass\" ) . beginChild ( \"span\" ). set ( \"title\" , \"a span\" ) . text ( \"Text\" ) . endChild () . beginChild ( \"button\" ). on ( \"click\" , ev => console . log ( \"Clicked!\" )) . text ( \"Click me\" ) . endChild () . endChild ()); JSX < div className = \"myClass\" > < span title = \"a span\" > Text < /span> < button on - click = { ev => console . log ( \"Clicked!\" )} > Click me < /button> < /div>","title":"HTML Elements"},{"location":"elements/#component","text":"Builder t . component ( MyComponent , { attr1 : \"value\" , attr2 : m => m . modelProp }) JSX < MyComponent attr1 = \"value\" attr2 = { m . modelProp } />","title":"Component"},{"location":"elements/#content","text":"Renders the specified content. Valid content types are: Primitive types: String, Number, Boolean Components Templates Template providers {model: ..., template: ...} An object with an associated template using setTemplate Arrays of valid content You can override the default template associated with the model by specifying the template attribute. Warning A content array is not observed for internal changes, but only when the whole array object changes. To observe an array, use the Foreach element or expression. Builder t . content ( m => m . myContent ) JSX < Content src = { m . myContent } /> < Content src = { m . myContent } template = { myTemplate } /> Expression < tagName > { m . myContent } < /tagName>","title":"Content"},{"location":"elements/#if","text":"Conditionally render a subtree if the condition is true. You can optionally specify a false subtree. This allows toggling parts of the UI based on the model\u2019s state. Builder t . if ( m => m . test == 2 , t1 => t1 . text ( \"True\" ), t1 => t1 . text ( \"False\" )); JSX < If condition = { m . test == 2 } > True < Else > False < /Else> < /If> Expression < tagName > { m . test == 2 ? <> True < /> : <> False < /> } < /tagName> < tagName > { m . test == 2 && <> True ( no else ) < />}</tagName>","title":"If"},{"location":"elements/#class","text":"Adds a class list to an HTML element or conditionally adds/removes it when a given expression is true. Builder t . class ( m => m . myClassList ); t . class ( m => \"my-class\" , m => m . myProp === true ); JSX < div > < Class condition = { m . myProp === true } name = \"my-class\" /> < Class name = { m . myClassList } /> < /div> < div className = \"class1 class2\" />","title":"Class"},{"location":"elements/#style","text":"Associates a static style object to an HTML element or dynamically binds a particular state property. Builder t => t . styles ({ \"color\" : m => m . myColor , \"font-size\" : \"13px\" }) t => t . style ( \"color\" , m => m . myColor ) JSX < div > < Style color = { m . myColor } fontSize = \"16px\" /> < /div> < div style = {{ color : m.myColor }} /> < div style - color = { m . myColor } /> Warning Static style properties provided as {styleProp: value, ...} won\u2019t be bound and will maintain their initial value.","title":"Style"},{"location":"elements/#foreach","text":"Specifies a template to be applied to each element of an array. The array is observed for subsequent changes and updates atomically propagate. Observed methods include: push , pop , sort , splice , shift , unshift , fill . To change an element\u2019s value, use the new non-standard set function or proxy the array using createObservableArray . Builder t => t . foreach ( m => m . items , t2 => t2 . beginChild ( \"span\" ) . text ( item => item . myItemProp ) . endChild ()); JSX < Foreach src = { m . items } > < span > { item . myItemProp } < /span> < /Foreach> Expression { m . items . forEach ( i => < span > { i . myItemProp } < /span>)} Warning Do not use the map function on an array here, as it behaves as expected for transformations (producing a new array) but does not bind the array. Warning Original array methods such as push will be overridden. Consider this for subsequent bulk operations on such arrays.","title":"Foreach"},{"location":"elements/#text","text":"Creates a text node. Builder t => t . text ( m => m . myText ) JSX < Text src = { m . myText } />","title":"Text"},{"location":"elements/#node","text":"Appends a DOM node as a child of the current element. Builder t => t . appendChild ( m => m . myDOMnode ) JSX < Node src = { m . myDOMnode } />","title":"Node"},{"location":"elements/#html","text":"Creates elements from an HTML string. Builder t => t . html ( m => m . myHtmlString ) JSX < Html src = { m . myHtmlString } />","title":"Html"}]}