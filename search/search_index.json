{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"WebApp Getting started import { mount } from \"@eusoft/webapp-core\"; const root = document.querySelector(\"body\"); mount(root, <div>Hello word</div>); Setup Install @eusoft/webapp-core and @eusoft/webapp-jsx packages using you favorite package manager. You will need a boundle tool to compile the code, you can use Vite or Rollup. Webpack, is not supported anymore. Vite if you are using vite, install the compiler package @eusoft/webapp-compiler-rollup as dev dependence. In vite.config.js import webapp from \"@eusoft/webapp-compiler-rollup\" export default defineConfig ({ //... plugins : [ webapp ({ //... compiler options }) ], esbuild : { jsx : \"preserve\" } }); Rollup if you are using roolup, install the compiler package @eusoft/webapp-compiler-rollup as dev dependence, add the plugin to your rollup config file. in rollup.config.js import webapp from \"@eusoft/webapp-compiler-rollup\" export default [ { //... plugins : [ // ... other plugins webapp ({ //compiler options }), ] } ]; Typescript If you are using typescript, ensure tsconfig has \"jsx\": \"preserve\" in tsconfig.json { \"compilerOptions\": { \"jsx\": \"preserve\", \"experimentalDecorators\": true, }, }","title":"Home"},{"location":"#webapp","text":"","title":"WebApp"},{"location":"#getting-started","text":"import { mount } from \"@eusoft/webapp-core\"; const root = document.querySelector(\"body\"); mount(root, <div>Hello word</div>);","title":"Getting started"},{"location":"#setup","text":"Install @eusoft/webapp-core and @eusoft/webapp-jsx packages using you favorite package manager. You will need a boundle tool to compile the code, you can use Vite or Rollup. Webpack, is not supported anymore.","title":"Setup"},{"location":"#vite","text":"if you are using vite, install the compiler package @eusoft/webapp-compiler-rollup as dev dependence. In vite.config.js import webapp from \"@eusoft/webapp-compiler-rollup\" export default defineConfig ({ //... plugins : [ webapp ({ //... compiler options }) ], esbuild : { jsx : \"preserve\" } });","title":"Vite"},{"location":"#rollup","text":"if you are using roolup, install the compiler package @eusoft/webapp-compiler-rollup as dev dependence, add the plugin to your rollup config file. in rollup.config.js import webapp from \"@eusoft/webapp-compiler-rollup\" export default [ { //... plugins : [ // ... other plugins webapp ({ //compiler options }), ] } ];","title":"Rollup"},{"location":"#typescript","text":"If you are using typescript, ensure tsconfig has \"jsx\": \"preserve\" in tsconfig.json { \"compilerOptions\": { \"jsx\": \"preserve\", \"experimentalDecorators\": true, }, }","title":"Typescript"},{"location":"behaviors/","text":"Behaviors","title":"Behaviors"},{"location":"behaviors/#behaviors","text":"","title":"Behaviors"},{"location":"components/","text":"Components Functional Component This example shows a simple functional component: function MyComponent ( props : { text : string }) { const show = () => { alert ( props . text ); }; return ( < div > { props . text } < button on - click = { ev => show ()} > Show < /button> < /div> ); } < MyComponent text = \"\" /> Explanation : A functional component is a function that receives props as input and returns JSX. In this example, the show function simply displays the text property in an alert box. Note The function is called only once during its lifecycle and is not re-executed when properties change. State Internal state can be tracked using a special const state = {} object You can configure the compiler to automatically track changes to specific variables: { au t oTrack : [ \"myVarName\" , /myRegExp/ ] } Alternatively, decorate the variable with Bind.track , for example: const myState = Bind.track({...}) . Warning The variable must be declared with const and initialized as an object. Example function App ( p : { theme : string }) { const state = { text : \"\" , }; const show = () => { alert ( state . text ); state . text = \"new\" ; }; return ( < main clasName = { p . theme } > < h1 > Function component < /h1> < input type = \"text\" value = { state . text } /> < button on - click = { show } > Show < /button> < /main> ) } Class Component Why Use a Class Component? In functional components, the internal state is encapsulated and cannot be accessed or extended directly from outside the component. If you need to modify or trigger actions on the component\u2019s state from outside, class components are more suitable. Here\u2019s an example of a class component: import { Component , type IComponentOptions } from \"@eusoft/webapp-core\" ; import { forModel } from \"@eusoft/webapp-jsx\" ; interface IOptions extends IComponentOptions { text : string ; } export class MyComponent extends Component < IOptions > { constructor ( options : IOptions ) { super (); this . init ( MyComponent , { template : forModel < this > ( m => ( < div > { m . text } < button on - click = { ev => m . show ()} > Show < /button> < /div> )), ... options , }); } show () { alert ( this . text ); } text : string ; } Key points : The class must extend Component or a subclass of it. The constructor must call this.init(MyComponent, {...options}) , where MyComponent is the class name. The options argument should extend IComponentOptions . Note All properties in options that have a corrispictive in the components class, will be automaticated assigned. Only properties in options intreface will be exposed as JSX attributes Compact Form To reduce boilerplate code, you can use the declareComponent helper function to declare a class component more concisely. The first argument is an object containing the class body (methods and properties), and the second argument is the component\u2019s template or default options. Example: import { declareComponent } from \"@eusoft/webapp-core\" ; const MyComponent = declareComponent ({ show : function () { alert ( this . text ); }, text : undefined as string }, m => ( < div > { m . text } < button on - click = { ev => m . show ()} > Show < /button> < /div> )); MyComponent is now a standard class component that you can: Instantiate directly: const x = new MyComponent({ text: \"Hello\" }); Use as a JSX element: <MyComponent text=\"Hello\" /> Extend in other class components: class MyNewComponent extends MyComponent { /* ... */ } Warning All properties must be initialized with a default value, that can be null / undefined Referencing a Class Component Here\u2019s how you can reference a class component instance in a functional component: const TextInput = declareComponent ({ selectAll : function () { ( this . context . element as HTMLInputElement ). select (); } }, m => < input type = \"text\" /> ); function Page () { const state : { input? : InstanceType < typeof TextInput > ; } = {}; return ( < div > < TextInput ref = { state . input } /> < button on - click = {() => state . input . selectAll ()} > Select < /button> < /div> ); } Explanation : - TextInput is a class component that includes a selectAll method. - The Page component is a functional component. It declares a reference to the TextInput instance using the ref attribute. - The underlying DOM element of TextInput is accessible via this.context.element . This demonstrates how class components can expose methods that can be called from outside the component, something that functional components do not provide by default. Options / Attributes / Props A class component\u2019s available JSX attributes are defined by the type of its options parameter. Specifically, this type is declared as the first generic argument of Component<TOptions> , and it determines which attributes can be set when using the component in JSX. In functional components, instead, the available JSX attributes correspond to the properties of the first argument passed to the function. The special content option maps to the child nodes declared inside your component in JSX. function MyComponent ( opt : { content : ViewNode }) { return < div > { opt . content } < /div>; } < MyComponent > < span > Hello < /span> < /MyComponent> If no content type is specified, the component cannot have children. If multiple children are supported, the content type must be an array. To support both JSX and code-based initialization and to constrain the content to a particular component type, declare it as: MyChildComponent | JsxTypedComponent < IMyChildComponentOptions > If any content is permissible, use the type ViewNode (which covers both single and multiple children). To make an option bindable, meaning it dynamically reacts to changes, it must be declared as Bindable . interface IMyOptions { text : Bindable < string > ; } A bindable option can accept different types of values: A direct value An observable property (something implementing IObservableProperty or extracted from an object using propOf ) A property/bind expression from an external model using Bind.external const myModel = { counter : 0 }; interface IMyComponentOptions { value1 : Bindable < number > ; value2 : Bindable < number > ; value3 : Bindable < string > ; value4 : Bindable < number > ; } const x = new MyComponent ({ value1 : 5 , value2 : Bind.external ( myModel , \"counter\" ), value3 : Bind.external ( myModel , a => a . counter . toString () + \" ticks\" ), value4 : propOf ( myModel , \"counter\" ) }); Note Unfortunately, there is no way to enforce strict type checks on these attributes in JSX, so any attribute is treated as \"bindable\" by default. In functional components, the actual values passed to props can be bind expressions (e.g., m => m.xxx ). These values are not meant to be read or manipulated outside the JSX. To enforce type check and avoid confusion, declare such options always as Bindable","title":"Components"},{"location":"components/#components","text":"","title":"Components"},{"location":"components/#functional-component","text":"This example shows a simple functional component: function MyComponent ( props : { text : string }) { const show = () => { alert ( props . text ); }; return ( < div > { props . text } < button on - click = { ev => show ()} > Show < /button> < /div> ); } < MyComponent text = \"\" /> Explanation : A functional component is a function that receives props as input and returns JSX. In this example, the show function simply displays the text property in an alert box. Note The function is called only once during its lifecycle and is not re-executed when properties change.","title":"Functional Component"},{"location":"components/#state","text":"Internal state can be tracked using a special const state = {} object You can configure the compiler to automatically track changes to specific variables: { au t oTrack : [ \"myVarName\" , /myRegExp/ ] } Alternatively, decorate the variable with Bind.track , for example: const myState = Bind.track({...}) . Warning The variable must be declared with const and initialized as an object. Example function App ( p : { theme : string }) { const state = { text : \"\" , }; const show = () => { alert ( state . text ); state . text = \"new\" ; }; return ( < main clasName = { p . theme } > < h1 > Function component < /h1> < input type = \"text\" value = { state . text } /> < button on - click = { show } > Show < /button> < /main> ) }","title":"State"},{"location":"components/#class-component","text":"","title":"Class Component"},{"location":"components/#why-use-a-class-component","text":"In functional components, the internal state is encapsulated and cannot be accessed or extended directly from outside the component. If you need to modify or trigger actions on the component\u2019s state from outside, class components are more suitable. Here\u2019s an example of a class component: import { Component , type IComponentOptions } from \"@eusoft/webapp-core\" ; import { forModel } from \"@eusoft/webapp-jsx\" ; interface IOptions extends IComponentOptions { text : string ; } export class MyComponent extends Component < IOptions > { constructor ( options : IOptions ) { super (); this . init ( MyComponent , { template : forModel < this > ( m => ( < div > { m . text } < button on - click = { ev => m . show ()} > Show < /button> < /div> )), ... options , }); } show () { alert ( this . text ); } text : string ; } Key points : The class must extend Component or a subclass of it. The constructor must call this.init(MyComponent, {...options}) , where MyComponent is the class name. The options argument should extend IComponentOptions . Note All properties in options that have a corrispictive in the components class, will be automaticated assigned. Only properties in options intreface will be exposed as JSX attributes","title":"Why Use a Class Component?"},{"location":"components/#compact-form","text":"To reduce boilerplate code, you can use the declareComponent helper function to declare a class component more concisely. The first argument is an object containing the class body (methods and properties), and the second argument is the component\u2019s template or default options. Example: import { declareComponent } from \"@eusoft/webapp-core\" ; const MyComponent = declareComponent ({ show : function () { alert ( this . text ); }, text : undefined as string }, m => ( < div > { m . text } < button on - click = { ev => m . show ()} > Show < /button> < /div> )); MyComponent is now a standard class component that you can: Instantiate directly: const x = new MyComponent({ text: \"Hello\" }); Use as a JSX element: <MyComponent text=\"Hello\" /> Extend in other class components: class MyNewComponent extends MyComponent { /* ... */ } Warning All properties must be initialized with a default value, that can be null / undefined","title":"Compact Form"},{"location":"components/#referencing-a-class-component","text":"Here\u2019s how you can reference a class component instance in a functional component: const TextInput = declareComponent ({ selectAll : function () { ( this . context . element as HTMLInputElement ). select (); } }, m => < input type = \"text\" /> ); function Page () { const state : { input? : InstanceType < typeof TextInput > ; } = {}; return ( < div > < TextInput ref = { state . input } /> < button on - click = {() => state . input . selectAll ()} > Select < /button> < /div> ); } Explanation : - TextInput is a class component that includes a selectAll method. - The Page component is a functional component. It declares a reference to the TextInput instance using the ref attribute. - The underlying DOM element of TextInput is accessible via this.context.element . This demonstrates how class components can expose methods that can be called from outside the component, something that functional components do not provide by default.","title":"Referencing a Class Component"},{"location":"components/#options-attributes-props","text":"A class component\u2019s available JSX attributes are defined by the type of its options parameter. Specifically, this type is declared as the first generic argument of Component<TOptions> , and it determines which attributes can be set when using the component in JSX. In functional components, instead, the available JSX attributes correspond to the properties of the first argument passed to the function. The special content option maps to the child nodes declared inside your component in JSX. function MyComponent ( opt : { content : ViewNode }) { return < div > { opt . content } < /div>; } < MyComponent > < span > Hello < /span> < /MyComponent> If no content type is specified, the component cannot have children. If multiple children are supported, the content type must be an array. To support both JSX and code-based initialization and to constrain the content to a particular component type, declare it as: MyChildComponent | JsxTypedComponent < IMyChildComponentOptions > If any content is permissible, use the type ViewNode (which covers both single and multiple children). To make an option bindable, meaning it dynamically reacts to changes, it must be declared as Bindable . interface IMyOptions { text : Bindable < string > ; } A bindable option can accept different types of values: A direct value An observable property (something implementing IObservableProperty or extracted from an object using propOf ) A property/bind expression from an external model using Bind.external const myModel = { counter : 0 }; interface IMyComponentOptions { value1 : Bindable < number > ; value2 : Bindable < number > ; value3 : Bindable < string > ; value4 : Bindable < number > ; } const x = new MyComponent ({ value1 : 5 , value2 : Bind.external ( myModel , \"counter\" ), value3 : Bind.external ( myModel , a => a . counter . toString () + \" ticks\" ), value4 : propOf ( myModel , \"counter\" ) }); Note Unfortunately, there is no way to enforce strict type checks on these attributes in JSX, so any attribute is treated as \"bindable\" by default. In functional components, the actual values passed to props can be bind expressions (e.g., m => m.xxx ). These values are not meant to be read or manipulated outside the JSX. To enforce type check and avoid confusion, declare such options always as Bindable","title":"Options / Attributes / Props"},{"location":"elements/","text":"Elements This chapter describes the different building blocks of the framework\u2019s rendering system, including how to define templates, bind data, and handle dynamic DOM updates. It covers the syntax and conventions for building reactive interfaces with both the fluent API (Builder) and JSX syntax. The elements and attributes described here allow you to construct flexible, data-driven UIs with live updates and minimal manual DOM management. Some elements are automatically detected using an expression inside the JSX as a shortcut. Template Define a new template. A template is a function that builds or updates a DOM tree for a given model. The template is \"live\": it monitors the model for changes and updates the DOM accordingly. At least one template must be mounted in your document using the mount(elementOrSelector, template) function. Builder import { template } from \"@eusoft/webapp-core\" ; template ( t => t ); JSX import { forModel } from \"@eusoft/webapp-jsx\" ; forModel < TModel > ( m => <> < />); forModel ( myModel , m => <> < />); < Template name = \"\" > < /Template> HTML Elements Standard HTML elements can be created using the fluent API in the template builder. In JSX, events are mapped using special on-* attributes, where * is the event name (e.g., on-click ). In addition to standard HTML attributes: focus : two-way boolean expression to get/set the focus status. visible : adds or removes the \"visible\" or \"hidden\" class to an element based on the boolean expression. html : sets the inner HTML of an element. text : sets the inner text of an element. For input , textarea , and select elements: value-mode : determines how the value update must be notified: change : when the value changes (default). focus : when the element loses focus. input : when the value changes due to user input. keyup : after every keyup event. pool : periodically checks for value changes every value-pool milliseconds. value-pool : interval in milliseconds (default: 500). Builder template ( t => t . beginChild ( \"div\" ). class ( \"myClass\" ) . beginChild ( \"span\" ). set ( \"title\" , \"a span\" ) . text ( \"Text\" ) . endChild () . beginChild ( \"button\" ). on ( \"click\" , ev => console . log ( \"Clicked!\" )) . text ( \"Click me\" ) . endChild () . endChild ()); JSX < div className = \"myClass\" > < span title = \"a span\" > Text < /span> < button on - click = { ev => console . log ( \"Clicked!\" )} > Click me < /button> < /div> Component Builder t . component ( MyComponent , { attr1 : \"value\" , attr2 : m => m . modelProp }) JSX < MyComponent attr1 = \"value\" attr2 = { m . modelProp } /> Content Renders the specified content. Valid content types are: Primitive types: String, Number, Boolean Components Templates Template providers {model: ..., template: ...} An object with an associated template using setTemplate Arrays of valid content You can override the default template associated with the model by specifying the template attribute. Warning A content array is not observed for internal changes, but only when the whole array object changes. To observe an array, use the Foreach element or expression. Builder t . content ( m => m . myContent ) JSX < Content src = { m . myContent } /> < Content src = { m . myContent } template = { myTemplate } /> Expression < tagName > { m . myContent } < /tagName> If Conditionally render a subtree if the condition is true. You can optionally specify a false subtree. This allows toggling parts of the UI based on the model\u2019s state. Builder t . if ( m => m . test == 2 , t1 => t1 . text ( \"True\" ), t1 => t1 . text ( \"False\" )); JSX < If condition = { m . test == 2 } > True < Else > False < /Else> < /If> Expression < tagName > { m . test == 2 ? <> True < /> : <> False < /> } < /tagName> < tagName > { m . test == 2 && <> True ( no else ) < />}</tagName> Class Adds a class list to an HTML element or conditionally adds/removes it when a given expression is true. Builder t . class ( m => m . myClassList ); t . class ( m => \"my-class\" , m => m . myProp === true ); JSX < div > < Class condition = { m . myProp === true } name = \"my-class\" /> < Class name = { m . myClassList } /> < /div> < div className = \"class1 class2\" /> Style Associates a static style object to an HTML element or dynamically binds a particular state property. Builder t => t . styles ({ \"color\" : m => m . myColor , \"font-size\" : \"13px\" }) t => t . style ( \"color\" , m => m . myColor ) JSX < div > < Style color = { m . myColor } fontSize = \"16px\" /> < /div> < div style = {{ color : m.myColor }} /> < div style - color = { m . myColor } /> Warning Static style properties provided as {styleProp: value, ...} won\u2019t be bound and will maintain their initial value. Foreach Specifies a template to be applied to each element of an array. The array is observed for subsequent changes and updates atomically propagate. Observed methods include: push , pop , sort , splice , shift , unshift , fill . To change an element\u2019s value, use the new non-standard set function or proxy the array using createObservableArray . Builder t => t . foreach ( m => m . items , t2 => t2 . beginChild ( \"span\" ) . text ( item => item . myItemProp ) . endChild ()); JSX < Foreach src = { m . items } > < span > { item . myItemProp } < /span> < /Foreach> Expression { m . items . forEach ( i => < span > { i . myItemProp } < /span>)} Warning Do not use the map function on an array here, as it behaves as expected for transformations (producing a new array) but does not bind the array. Warning Original array methods such as push will be overridden. Consider this for subsequent bulk operations on such arrays. Text Creates a text node. Builder t => t . text ( m => m . myText ) JSX < Text src = { m . myText } /> Node Appends a DOM node as a child of the current element. Builder t => t . appendChild ( m => m . myDOMnode ) JSX < Node src = { m . myDOMnode } /> Html Creates elements from an HTML string. Builder t => t . html ( m => m . myHtmlString ) JSX < Html src = { m . myHtmlString } />","title":"Elements"},{"location":"elements/#elements","text":"This chapter describes the different building blocks of the framework\u2019s rendering system, including how to define templates, bind data, and handle dynamic DOM updates. It covers the syntax and conventions for building reactive interfaces with both the fluent API (Builder) and JSX syntax. The elements and attributes described here allow you to construct flexible, data-driven UIs with live updates and minimal manual DOM management. Some elements are automatically detected using an expression inside the JSX as a shortcut.","title":"Elements"},{"location":"elements/#template","text":"Define a new template. A template is a function that builds or updates a DOM tree for a given model. The template is \"live\": it monitors the model for changes and updates the DOM accordingly. At least one template must be mounted in your document using the mount(elementOrSelector, template) function. Builder import { template } from \"@eusoft/webapp-core\" ; template ( t => t ); JSX import { forModel } from \"@eusoft/webapp-jsx\" ; forModel < TModel > ( m => <> < />); forModel ( myModel , m => <> < />); < Template name = \"\" > < /Template>","title":"Template"},{"location":"elements/#html-elements","text":"Standard HTML elements can be created using the fluent API in the template builder. In JSX, events are mapped using special on-* attributes, where * is the event name (e.g., on-click ). In addition to standard HTML attributes: focus : two-way boolean expression to get/set the focus status. visible : adds or removes the \"visible\" or \"hidden\" class to an element based on the boolean expression. html : sets the inner HTML of an element. text : sets the inner text of an element. For input , textarea , and select elements: value-mode : determines how the value update must be notified: change : when the value changes (default). focus : when the element loses focus. input : when the value changes due to user input. keyup : after every keyup event. pool : periodically checks for value changes every value-pool milliseconds. value-pool : interval in milliseconds (default: 500). Builder template ( t => t . beginChild ( \"div\" ). class ( \"myClass\" ) . beginChild ( \"span\" ). set ( \"title\" , \"a span\" ) . text ( \"Text\" ) . endChild () . beginChild ( \"button\" ). on ( \"click\" , ev => console . log ( \"Clicked!\" )) . text ( \"Click me\" ) . endChild () . endChild ()); JSX < div className = \"myClass\" > < span title = \"a span\" > Text < /span> < button on - click = { ev => console . log ( \"Clicked!\" )} > Click me < /button> < /div>","title":"HTML Elements"},{"location":"elements/#component","text":"Builder t . component ( MyComponent , { attr1 : \"value\" , attr2 : m => m . modelProp }) JSX < MyComponent attr1 = \"value\" attr2 = { m . modelProp } />","title":"Component"},{"location":"elements/#content","text":"Renders the specified content. Valid content types are: Primitive types: String, Number, Boolean Components Templates Template providers {model: ..., template: ...} An object with an associated template using setTemplate Arrays of valid content You can override the default template associated with the model by specifying the template attribute. Warning A content array is not observed for internal changes, but only when the whole array object changes. To observe an array, use the Foreach element or expression. Builder t . content ( m => m . myContent ) JSX < Content src = { m . myContent } /> < Content src = { m . myContent } template = { myTemplate } /> Expression < tagName > { m . myContent } < /tagName>","title":"Content"},{"location":"elements/#if","text":"Conditionally render a subtree if the condition is true. You can optionally specify a false subtree. This allows toggling parts of the UI based on the model\u2019s state. Builder t . if ( m => m . test == 2 , t1 => t1 . text ( \"True\" ), t1 => t1 . text ( \"False\" )); JSX < If condition = { m . test == 2 } > True < Else > False < /Else> < /If> Expression < tagName > { m . test == 2 ? <> True < /> : <> False < /> } < /tagName> < tagName > { m . test == 2 && <> True ( no else ) < />}</tagName>","title":"If"},{"location":"elements/#class","text":"Adds a class list to an HTML element or conditionally adds/removes it when a given expression is true. Builder t . class ( m => m . myClassList ); t . class ( m => \"my-class\" , m => m . myProp === true ); JSX < div > < Class condition = { m . myProp === true } name = \"my-class\" /> < Class name = { m . myClassList } /> < /div> < div className = \"class1 class2\" />","title":"Class"},{"location":"elements/#style","text":"Associates a static style object to an HTML element or dynamically binds a particular state property. Builder t => t . styles ({ \"color\" : m => m . myColor , \"font-size\" : \"13px\" }) t => t . style ( \"color\" , m => m . myColor ) JSX < div > < Style color = { m . myColor } fontSize = \"16px\" /> < /div> < div style = {{ color : m.myColor }} /> < div style - color = { m . myColor } /> Warning Static style properties provided as {styleProp: value, ...} won\u2019t be bound and will maintain their initial value.","title":"Style"},{"location":"elements/#foreach","text":"Specifies a template to be applied to each element of an array. The array is observed for subsequent changes and updates atomically propagate. Observed methods include: push , pop , sort , splice , shift , unshift , fill . To change an element\u2019s value, use the new non-standard set function or proxy the array using createObservableArray . Builder t => t . foreach ( m => m . items , t2 => t2 . beginChild ( \"span\" ) . text ( item => item . myItemProp ) . endChild ()); JSX < Foreach src = { m . items } > < span > { item . myItemProp } < /span> < /Foreach> Expression { m . items . forEach ( i => < span > { i . myItemProp } < /span>)} Warning Do not use the map function on an array here, as it behaves as expected for transformations (producing a new array) but does not bind the array. Warning Original array methods such as push will be overridden. Consider this for subsequent bulk operations on such arrays.","title":"Foreach"},{"location":"elements/#text","text":"Creates a text node. Builder t => t . text ( m => m . myText ) JSX < Text src = { m . myText } />","title":"Text"},{"location":"elements/#node","text":"Appends a DOM node as a child of the current element. Builder t => t . appendChild ( m => m . myDOMnode ) JSX < Node src = { m . myDOMnode } />","title":"Node"},{"location":"elements/#html","text":"Creates elements from an HTML string. Builder t => t . html ( m => m . myHtmlString ) JSX < Html src = { m . myHtmlString } />","title":"Html"},{"location":"how-it-works/","text":"How it works The framework is an MVVM framework that doesn\u2019t require any ceremony. It has no virtual DOM, no special conventions, and doesn\u2019t use hooks. The core engine is a template builder that simplifies DOM construction associated with a particular model through a fluent API. import { template } from \"@eusoft/webapp-core\" ; const myTemplate = template ( t => t . beginChild ( \"div\" ). class ( \"myClass\" ) . beginChild ( \"span\" ). set ( \"title\" , \"a span\" ) . text ( \"Text\" ) . endChild () . beginChild ( \"button\" ). on ( \"click\" , ev => console . log ( \"Clicked!\" )) . text ( \"Click me\" ) . endChild () . endChild ()); that will produce < div className = \"myClass\" > < span title = \"a span\" > Text </ span > < button click = \"console.log(\" Clicked !\")\" > Click me </ button > </ div > The template can be mounted using the mount function, specifying the DOM element or selector and the template itself. import { mount } from \"@eusoft/webapp-core\" ; mount ( \"body\" , myTemplate ); mount ( document . body , myTemplate ); mount ( \"#myRootElementId\" , myTemplate ); Model binding A template can have a model associated. Once you have the model, you can create bind expression to associate a particular value for a template to a model import { mount , template } from \"@eusoft/webapp-core\" ; interface IMyModel { text : string ; } const myTemplate = template < IMyModel > ( t => t . beginChild ( \"span\" ). text ( m => m . text ). endChild ()); const model = { } as IMyModel ; mount ( document . body , myTemplate , model ); model . text = \"Hello word\" ; Any changes to a model property will be propagated to each binding expression that uses it. In this example, the inner text of the span will reflect the value of the text property in the model Tracking binding Binding expressions can have arbitrary complexity. Behind the scenes, a Proxy is created to track the expression and collect all references, even complex ones. Once all references are collected, each referenced property descriptor is modified to make it observable and to provide a notification when the property changes. The original descriptor is preserved and called back as needed. These observed properties are stored inside the special symbol @props within the object. In this scenario model => model . obj . test ? model.c : model.d ; // the old obj and obj.test would be untracked, new obj, obj.test, model.c tracked, and model.d untracked. model . obj = { test : true }; //no effect, d is not tracked model . d = 'new value' ; //model.c untracked and model.d tracked model . obj . test = false ; Only when the value of the binding expression really changes (has a new value different from the last one), the template will be updated. Array Tracking When a model is represented by an array, the framework automatically tracks changes to both the array and its items. It overrides the native array methods so that any modification will trigger updates in the template. Observed methods include: push , pop , sort , splice , shift , unshift , fill . A new method, myArray.set(index, value) is also available to change an element\u2019s value directly, since the native array methods do not support 'observe' this operation. To use direct item assignment myArray[index] = value , you can use wrap the array with createObservableArray function to create a proxy for the array. JSX Compiler WebApp supports JSX syntax through the @eusoft/webapp-jsx package. A compiler is available to convert JSX code into the framework template builder syntax @eusoft/webapp-compiler . A plugin for Rollup or Vite is available to handle the compilation @eusoft/webapp-compiler-rollup . for example, the following JSX code: export function ConfirmBox ( options : IConfirmBoxOptions ) { return < div className = \"confirm-box\" > { options . isSuccess ? < MaterialIcon name = \"check_circle\" style = \"green\" /> : < MaterialIcon name = \"error\" style = \"red\" /> } < div className = \"message\" > < NodeView > { options . message } < /NodeView> < /div> { options . actions && < div className = \"actions\" > { options . actions ? . forEach ( a => < Action name = { a . name } style = {[ \"action\" , \"text\" ]} type = { a . type } onExecuteAsync = { a . executeAsync } > { a . icon } { formatText ( a . text )} < /Action> )} < /div> } < /div> } will be converted in function ConfirmBox ( options ) { return template ( t => t . beginChild ( \"div\" ). class ( \"confirm-box\" ) . if ( Bind . exp ( options => options . isSuccess ), template ( t2 => t2 . component ( MaterialIcon , ({ \"name\" : \"check_circle\" , \"style\" : \"green\" }))), template ( t2 => t2 . component ( MaterialIcon , ({ \"name\" : \"error\" , \"style\" : \"red\" }))) ) . beginChild ( \"div\" ). class ( \"message\" ) . component ( NodeView , ({ \"content\" : Bind . exp ( options => options . message )})). endChild () . if ( Bind . exp ( options => options . actions ), template ( t2 => t2 . beginChild ( \"div\" ). class ( \"actions\" ) . foreach ( Bind . exp ( options => options . actions ), template ( t5 => t5 . component ( Action , ({ \"name\" : Bind . exp ( a => a . name ), \"style\" : [ \"action\" , \"text\" ], \"type\" : Bind . exp ( a => a . type ), \"onExecuteAsync\" : Bind . exp ( a => a . executeAsync ), \"content\" : { model : t5.model , template : template ( t6 => t6 . content ( Bind . exp ( a => a . icon ), false ). content ( Bind . exp ( a => use ( a , formatText )( a . text )), false )) }}))) ) . endChild () ) ) . endChild () ); }","title":"How it works"},{"location":"how-it-works/#how-it-works","text":"The framework is an MVVM framework that doesn\u2019t require any ceremony. It has no virtual DOM, no special conventions, and doesn\u2019t use hooks. The core engine is a template builder that simplifies DOM construction associated with a particular model through a fluent API. import { template } from \"@eusoft/webapp-core\" ; const myTemplate = template ( t => t . beginChild ( \"div\" ). class ( \"myClass\" ) . beginChild ( \"span\" ). set ( \"title\" , \"a span\" ) . text ( \"Text\" ) . endChild () . beginChild ( \"button\" ). on ( \"click\" , ev => console . log ( \"Clicked!\" )) . text ( \"Click me\" ) . endChild () . endChild ()); that will produce < div className = \"myClass\" > < span title = \"a span\" > Text </ span > < button click = \"console.log(\" Clicked !\")\" > Click me </ button > </ div > The template can be mounted using the mount function, specifying the DOM element or selector and the template itself. import { mount } from \"@eusoft/webapp-core\" ; mount ( \"body\" , myTemplate ); mount ( document . body , myTemplate ); mount ( \"#myRootElementId\" , myTemplate );","title":"How it works"},{"location":"how-it-works/#model-binding","text":"A template can have a model associated. Once you have the model, you can create bind expression to associate a particular value for a template to a model import { mount , template } from \"@eusoft/webapp-core\" ; interface IMyModel { text : string ; } const myTemplate = template < IMyModel > ( t => t . beginChild ( \"span\" ). text ( m => m . text ). endChild ()); const model = { } as IMyModel ; mount ( document . body , myTemplate , model ); model . text = \"Hello word\" ; Any changes to a model property will be propagated to each binding expression that uses it. In this example, the inner text of the span will reflect the value of the text property in the model","title":"Model binding"},{"location":"how-it-works/#tracking-binding","text":"Binding expressions can have arbitrary complexity. Behind the scenes, a Proxy is created to track the expression and collect all references, even complex ones. Once all references are collected, each referenced property descriptor is modified to make it observable and to provide a notification when the property changes. The original descriptor is preserved and called back as needed. These observed properties are stored inside the special symbol @props within the object. In this scenario model => model . obj . test ? model.c : model.d ; // the old obj and obj.test would be untracked, new obj, obj.test, model.c tracked, and model.d untracked. model . obj = { test : true }; //no effect, d is not tracked model . d = 'new value' ; //model.c untracked and model.d tracked model . obj . test = false ; Only when the value of the binding expression really changes (has a new value different from the last one), the template will be updated.","title":"Tracking binding"},{"location":"how-it-works/#array-tracking","text":"When a model is represented by an array, the framework automatically tracks changes to both the array and its items. It overrides the native array methods so that any modification will trigger updates in the template. Observed methods include: push , pop , sort , splice , shift , unshift , fill . A new method, myArray.set(index, value) is also available to change an element\u2019s value directly, since the native array methods do not support 'observe' this operation. To use direct item assignment myArray[index] = value , you can use wrap the array with createObservableArray function to create a proxy for the array.","title":"Array Tracking"},{"location":"how-it-works/#jsx-compiler","text":"WebApp supports JSX syntax through the @eusoft/webapp-jsx package. A compiler is available to convert JSX code into the framework template builder syntax @eusoft/webapp-compiler . A plugin for Rollup or Vite is available to handle the compilation @eusoft/webapp-compiler-rollup . for example, the following JSX code: export function ConfirmBox ( options : IConfirmBoxOptions ) { return < div className = \"confirm-box\" > { options . isSuccess ? < MaterialIcon name = \"check_circle\" style = \"green\" /> : < MaterialIcon name = \"error\" style = \"red\" /> } < div className = \"message\" > < NodeView > { options . message } < /NodeView> < /div> { options . actions && < div className = \"actions\" > { options . actions ? . forEach ( a => < Action name = { a . name } style = {[ \"action\" , \"text\" ]} type = { a . type } onExecuteAsync = { a . executeAsync } > { a . icon } { formatText ( a . text )} < /Action> )} < /div> } < /div> } will be converted in function ConfirmBox ( options ) { return template ( t => t . beginChild ( \"div\" ). class ( \"confirm-box\" ) . if ( Bind . exp ( options => options . isSuccess ), template ( t2 => t2 . component ( MaterialIcon , ({ \"name\" : \"check_circle\" , \"style\" : \"green\" }))), template ( t2 => t2 . component ( MaterialIcon , ({ \"name\" : \"error\" , \"style\" : \"red\" }))) ) . beginChild ( \"div\" ). class ( \"message\" ) . component ( NodeView , ({ \"content\" : Bind . exp ( options => options . message )})). endChild () . if ( Bind . exp ( options => options . actions ), template ( t2 => t2 . beginChild ( \"div\" ). class ( \"actions\" ) . foreach ( Bind . exp ( options => options . actions ), template ( t5 => t5 . component ( Action , ({ \"name\" : Bind . exp ( a => a . name ), \"style\" : [ \"action\" , \"text\" ], \"type\" : Bind . exp ( a => a . type ), \"onExecuteAsync\" : Bind . exp ( a => a . executeAsync ), \"content\" : { model : t5.model , template : template ( t6 => t6 . content ( Bind . exp ( a => a . icon ), false ). content ( Bind . exp ( a => use ( a , formatText )( a . text )), false )) }}))) ) . endChild () ) ) . endChild () ); }","title":"JSX Compiler"}]}